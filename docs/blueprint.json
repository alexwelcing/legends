{
  "dataModels": [
    {
      "name": "AgentEntity",
      "fields": [
        "agent_id: UUID",
        "status: Enum(Idle, Busy, Error, Offline)",
        "capabilities: Vector<String>",
        "runtime_metrics: Struct(cpu, memory, latency)",
        "current_task: Option<String>"
      ],
      "relationships": "One-to-Many with TelemetryPacket; Many-to-One with SwarmCluster"
    },
    {
      "name": "InferenceProviderConfig",
      "fields": [
        "provider_id: UUID",
        "provider_name: String",
        "endpoint_url: String",
        "model_spec: String",
        "usage_limit: u64",
        "is_active: Boolean"
      ],
      "relationships": "One-to-Many with InferenceLog; Referenced by SystemSettings (secrets stored separately)"
    },
    {
      "name": "TelemetryPacket",
      "fields": [
        "source_id: UUID",
        "timestamp: u64",
        "metric_type: String",
        "payload: JSON",
        "severity: Enum(Info, Warning, Critical)"
      ],
      "relationships": "Linked to AgentEntity"
    },
    {
      "name": "WorkspaceLayout",
      "fields": [
        "layout_id: UUID",
        "user_id: String",
        "theme_preference: String",
        "window_positions: JSON",
        "active_panels: Vector<String>"
      ],
      "relationships": "Bound to UserSession"
    }
  ],
  "components": [
    {
      "name": "RustSwarmOrchestrator",
      "responsibility": "Manages agent lifecycles, handles concurrency via Tokio, and maintains the global state of the swarm.",
      "stateRequired": [
        "AgentRegistry",
        "TaskQueue",
        "EnvironmentContext"
      ]
    },
    {
      "name": "InferenceGateway",
      "responsibility": "Securely proxies requests to AI providers, handles hot-swapping of models, and tracks token usage.",
      "stateRequired": [
        "ActiveProviderConfig",
        "RateLimiters",
        "CircuitBreakerStatus"
      ]
    },
    {
      "name": "TelemetryStreamer",
      "responsibility": "Aggregates metrics from agents and pushes updates to the frontend via WebSockets/gRPC.",
      "stateRequired": [
        "WebSocketConnections",
        "MetricBuffer"
      ]
    },
    {
      "name": "IsometricViewport (React)",
      "responsibility": "Renders the RTS-style, Mega Man Legends-inspired 3D/2D visualization of the swarm and containers.",
      "stateRequired": [
        "CameraAngle",
        "EntityCoordinates",
        "RenderAssets"
      ]
    },
    {
      "name": "TerminalMultiplexer",
      "responsibility": "Renders customizable, draggable terminal windows for raw logs and command inputs.",
      "stateRequired": [
        "ActiveShellSessions",
        "CommandHistory",
        "ThemeConfig"
      ]
    }
  ],
  "logicFlows": [
    "Environment Detection: Rust Core starts -> Checks ENV variables (Local vs Codespace) -> Configures port binding and API base URLs -> Exposes capabilities to Frontend.",
    "Real-time Telemetry: Agent generates data -> Rust Orchestrator receives via channel -> TelemetryStreamer serializes to Protobuf/JSON -> Pushed to WebSocket -> IsometricViewport updates entity animation/stats.",
    "Inference Proxying: User/Agent requests completion -> InferenceGateway validates Auth -> Selects Active Provider -> Proxies Request (adding server-side API Key) -> Logs usage -> Returns response.",
    "Hot-Swap Provider: User selects new Model in UI -> Request sent to Rust Core -> InferenceGateway pauses queue -> Updates configuration -> Test connection -> Resumes queue with new provider."
  ],
  "securityRequirements": [
    "API Keys for inference providers must be stored in server-side environment variables or encrypted vaults, never sent to the client.",
    "WebSocket connections must require an initial handshake with an authentication token generated by the Rust backend.",
    "All inputs from the TerminalMultiplexer must be sanitized and validated against a whitelist of allowed commands to prevent injection.",
    "Agent runtimes must operate within sandboxed threads or containers to prevent host system compromise.",
    "Cross-Origin Resource Sharing (CORS) must be strictly configured based on the detected environment (Localhost vs Codespace URL)."
  ]
}
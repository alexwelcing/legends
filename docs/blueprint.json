{
  "dataModels": [
    {
      "name": "AgentEntity",
      "fields": [
        "agent_id: uuid",
        "alias: string",
        "archetype: string",
        "runtime_status: enum(idle, active, error, dormant)",
        "coordinates: vector3(x,y,z)",
        "resources: struct(cpu, ram, gpu)",
        "current_objective: string"
      ],
      "relationships": "Belongs to a SwarmCluster; Generates many TelemetryPackets; Initiates InferenceJobs"
    },
    {
      "name": "SwarmCluster",
      "fields": [
        "cluster_id: uuid",
        "environment_context: enum(local, codespace, k8s)",
        "base_station_ref: string",
        "active_agent_count: integer",
        "health_score: float"
      ],
      "relationships": "Aggregates multiple AgentEntities; Managed by SystemOrchestrator"
    },
    {
      "name": "TelemetryPacket",
      "fields": [
        "timestamp: u64",
        "source_id: uuid",
        "metric_type: string",
        "payload: json",
        "alert_level: enum(info, warning, critical)"
      ],
      "relationships": "Linked to AgentEntity or ContainerRuntime"
    },
    {
      "name": "InferenceJob",
      "fields": [
        "job_id: uuid",
        "provider: enum(claude, huggingface, opencode)",
        "model_endpoint: string",
        "input_context: text",
        "output_response: text",
        "latency_ms: u32",
        "cost_token: float"
      ],
      "relationships": "Requested by AgentEntity or UserTerminal; Proxied via InferenceGateway"
    },
    {
      "name": "ViewConfiguration",
      "fields": [
        "config_id: uuid",
        "theme_preset: enum(mega_legends_retro, wireframe, high_contrast)",
        "camera_angle: vector3",
        "active_widgets: list<string>",
        "rendering_mode: enum(webgl, canvas_2d)"
      ],
      "relationships": "Applied to TerminalSession"
    }
  ],
  "components": [
    {
      "name": "RustCoreOrchestrator",
      "responsibility": "Main backend service running in the container. Manages thread pools for agent communications, aggregates metrics, and serves the WebSocket stream to the frontend.",
      "stateRequired": [
        "AgentRegistry",
        "EnvironmentConfig",
        "WebSocketConnectionPool"
      ]
    },
    {
      "name": "InferenceGateway",
      "responsibility": "Rust-based proxy layer that handles authentication and rate-limiting for external AI providers (Claude, Hugging Face). Sanitizes prompts and logs usage.",
      "stateRequired": [
        "ProviderApiKeys",
        "JobQueue",
        "TokenUsageStats"
      ]
    },
    {
      "name": "ViewportEngine",
      "responsibility": "React/WebGL component (using React Three Fiber) that renders the RTS-style map. Handles the 'Mega Man Legends' aesthetic including low-poly models, retro textures, and camera controls.",
      "stateRequired": [
        "CameraPosition",
        "RenderedEntityList",
        "AssetCache"
      ]
    },
    {
      "name": "DigiBeetleUnit",
      "responsibility": "Visual representation of an agent or container within the Viewport. Displays health bars, status icons, and movement animations based on real-time telemetry.",
      "stateRequired": [
        "EntityID",
        "LocalCoordinates",
        "AnimationState",
        "HealthStatus"
      ]
    },
    {
      "name": "CommandOverlayUI",
      "responsibility": "Retro-styled menu system overlaid on the 3D view. Handles user input for spawning agents, viewing logs, and configuring the environment variables.",
      "stateRequired": [
        "ActiveMenuSelection",
        "SystemLogBuffer",
        "UserPreferences"
      ]
    }
  ],
  "logicFlows": [
    "Initialization: Rust backend detects runtime (Codespace/Local) -> Loads .env -> Starts WebSocket Server -> React Client Connects -> Handshake validates Auth.",
    "Data Sync: Agents/Containers push metrics to RustCore -> RustCore processes and aggregates -> Broadcasts binary diffs via WebSocket -> ViewportEngine updates DigiBeetleUnit positions and stats.",
    "Inference Loop: User/Agent triggers request -> Rust InferenceGateway injects context -> Calls External API (Claude/HF) -> Streams response back to CommandOverlayUI.",
    "Swarm Construction: User selects 'Spin Up' in UI -> Sends payload to RustCore -> RustCore utilizes Docker/Process API to spawn new runtime -> New Entity registers in SwarmCluster."
  ],
  "securityRequirements": [
    "Environment Variable Isolation: API keys for inference providers must remain server-side in Rust memory, never sent to the React client.",
    "WebSocket Authentication: Handshake must verify a session token generated by the GitHub Codespace environment to prevent unauthorized external access.",
    "Container Sandboxing: Dynamic tools spun up by the swarm must run with limited permissions to prevent host system compromise.",
    "Input Sanitization: All commands passed from the retro UI to the shell executor must be scrubbed to prevent command injection."
  ]
}
{
  "dataModels": [
    {
      "name": "CourseConfiguration",
      "fields": [
        "courseId",
        "layoutTopology",
        "redConeCoordinates",
        "yellowConeCoordinates",
        "startPoint",
        "finishLine"
      ],
      "relationships": "Contains multiple DifficultyTier definitions"
    },
    {
      "name": "DifficultyTier",
      "fields": [
        "rankLevel",
        "timeLimitSeconds",
        "zennyRewardAmount",
        "uniqueRewardItemId",
        "isUniqueClaimed"
      ],
      "relationships": "Linked to specific CourseConfiguration"
    },
    {
      "name": "RaceSession",
      "fields": [
        "currentTimerValue",
        "yellowConesHit",
        "currentCourseId",
        "selectedDifficulty",
        "isTimerPaused"
      ],
      "relationships": "Instantiated by RaceStateManager during gameplay"
    },
    {
      "name": "PlayerProgression",
      "fields": [
        "totalZenny",
        "completedRanksMap",
        "inventoryItems"
      ],
      "relationships": "Persists state across game sessions"
    }
  ],
  "components": [
    {
      "name": "RaceStateManager",
      "responsibility": "Orchestrates the lifecycle of a race event from initialization to completion or failure.",
      "stateRequired": [
        "raceActive",
        "currentPhase",
        "selectedCourse"
      ],
      "methods": [
        "initializeRace(courseId, rank)",
        "startCountdown()",
        "endRace(result)",
        "resetCourse()"
      ]
    },
    {
      "name": "ConeInteractionManager",
      "responsibility": "Handles collision detection with course markers and processes the time-stop mechanics for yellow cones.",
      "stateRequired": [
        "activeYellowCones",
        "pauseEffectDuration"
      ],
      "methods": [
        "detectCollision(playerVector, coneType)",
        "triggerTimeFreeze()",
        "enforceBoundary(redConeData)"
      ]
    },
    {
      "name": "TimerSystem",
      "responsibility": "Manages the countdown clock, including the decrement logic and suspension states when bonuses are acquired.",
      "stateRequired": [
        "timeRemaining",
        "isPaused",
        "pauseEndTime"
      ],
      "methods": [
        "decrementTime()",
        "applyTimeBonus(seconds)",
        "pauseCountdown(duration)",
        "checkTimeExpiration()"
      ]
    },
    {
      "name": "RewardCalculator",
      "responsibility": "Determines payouts based on difficulty rank and completion status.",
      "stateRequired": [
        "rankRewardTable",
        "firstTimeBonusFlag"
      ],
      "methods": [
        "calculateZenny(rank)",
        "awardUniqueItem(rank)",
        "updateSaveData()"
      ]
    }
  ],
  "logicFlows": [
    "Race Initiation: Player selects Course (1-3) -> Selects Difficulty (D-A) -> System loads geometry and cone placement -> TimerSystem initializes with rank-specific limit.",
    "Gameplay Loop: Input handling moves MegaMan -> Physics engine checks collisions -> If Yellow Cone hit: Trigger ConeInteractionManager, Pause TimerSystem, Play SFX -> If Red Cone hit: Physics rebound/Collision response.",
    "End Condition (Success): Player crosses finish line -> RaceStateManager stops timer -> RewardCalculator checks Rank -> Grants Zenny -> If Rank A and first completion: Grant Unique Reward -> Save PlayerProgression.",
    "End Condition (Failure): TimerSystem reaches zero -> RaceStateManager triggers Game Over state -> Prompt retry or exit."
  ],
  "securityRequirements": [
    "Validate race completion times against theoretical minimums to prevent speed-hacking.",
    "Encrypt local save files to prevent Zenny injection or unearned rank unlocking.",
    "Sanitize inputs on difficulty selection to prevent accessing undefined ranks or debug modes."
  ]
}